name: Visual Web Testing

on:
  # Trigger on PR events (parallel to code review)
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [main, develop, master]
  
  # Trigger after successful builds
  workflow_run:
    workflows: ["Claude Code Review"]
    types: [completed]
    branches: [main, develop, master]
  
  # Manual trigger for testing
  workflow_dispatch:
    inputs:
      test_environment:
        description: 'Environment to test'
        required: true
        default: 'preview'
        type: choice
        options:
          - preview
          - development
          - staging
      browser:
        description: 'Browser to test with'
        required: true
        default: 'chromium'
        type: choice
        options:
          - chromium
          - firefox
          - webkit
      viewport:
        description: 'Viewport size'
        required: true
        default: 'desktop'
        type: choice
        options:
          - mobile
          - tablet
          - desktop
          - all

  # Scheduled regression testing
  schedule:
    - cron: '0 2 * * 1-5'  # Weekdays at 2 AM UTC

env:
  NODE_VERSION: '18'
  ASTRO_TELEMETRY_DISABLED: 1

jobs:
  visual-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    permissions:
      contents: read
      pull-requests: write
      issues: write
      checks: write
      statuses: write

    strategy:
      fail-fast: false
      matrix:
        browser: ${{ github.event_name == 'workflow_dispatch' && fromJSON(format('["{0}"]', github.event.inputs.browser)) || fromJSON('["chromium", "firefox"]') }}
        viewport: ${{ github.event_name == 'workflow_dispatch' && fromJSON(format('["{0}"]', github.event.inputs.viewport)) || fromJSON('["desktop", "mobile"]') }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: |
          npm ci
          # Install Puppeteer and testing dependencies globally for workflow
          npm install -g puppeteer playwright @playwright/test lighthouse axe-core

      - name: Get changed files in PR
        id: changed-files
        if: github.event_name == 'pull_request'
        run: |
          # Get list of changed files in the PR
          CHANGED_FILES=$(gh api repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/files \
            --jq '.[].filename' | grep -E '\.(astro|md|mdx)$' | grep '^src/pages/' || echo "")
          
          echo "changed_files=$CHANGED_FILES" >> $GITHUB_OUTPUT
          echo "Changed page files in PR:"
          echo "$CHANGED_FILES"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if visual testing is needed
        id: check-testing-needed
        run: |
          CHANGED_FILES="${{ steps.changed-files.outputs.changed_files }}"
          
          # Always run for manual dispatch, scheduled runs, or workflow_run
          if [ "${{ github.event_name }}" != "pull_request" ]; then
            echo "needs_testing=true" >> $GITHUB_OUTPUT
            echo "Testing needed: Non-PR trigger"
            exit 0
          fi
          
          # Check if any page files or components were changed
          if echo "$CHANGED_FILES" | grep -E '\.(astro|md|mdx)$' > /dev/null; then
            echo "needs_testing=true" >> $GITHUB_OUTPUT
            echo "Testing needed: Page or component files changed"
          elif git diff --name-only HEAD~1 HEAD | grep -E '^src/(components|layouts)/' > /dev/null; then
            echo "needs_testing=true" >> $GITHUB_OUTPUT
            echo "Testing needed: Component or layout files changed"
          else
            echo "needs_testing=false" >> $GITHUB_OUTPUT
            echo "Testing not needed: No relevant files changed"
          fi

      - name: Build Astro site
        if: steps.check-testing-needed.outputs.needs_testing == 'true'
        run: |
          npm run build
          echo "Build completed successfully"

      - name: Start preview server
        if: steps.check-testing-needed.outputs.needs_testing == 'true'
        run: |
          npm run preview &
          echo "PREVIEW_PID=$!" >> $GITHUB_ENV
          # Wait for server to be ready
          timeout 60 bash -c 'until curl -s http://localhost:4321 > /dev/null; do sleep 2; done'
          echo "Preview server is ready"

      - name: Install Playwright browsers
        if: steps.check-testing-needed.outputs.needs_testing == 'true'
        run: npx playwright install --with-deps ${{ matrix.browser }}

      - name: Comment on PR when testing is skipped
        if: github.event_name == 'pull_request' && steps.check-testing-needed.outputs.needs_testing == 'false'
        run: |
          gh pr comment ${{ github.event.pull_request.number }} --body "## ðŸ“¸ Visual Testing Skipped
          
          Visual testing was skipped because no relevant files were changed in this PR.
          
          **Files that trigger visual testing:**
          - Pages: \`src/pages/*.astro\`, \`src/pages/*.md\`, \`src/pages/*.mdx\`
          - Components: \`src/components/**/*\`
          - Layouts: \`src/layouts/**/*\`
          
          If you believe visual testing should run, you can manually trigger it from the Actions tab.
          
          ---
          *Visual testing automation*"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Run visual tests
        if: steps.check-testing-needed.outputs.needs_testing == 'true'
        id: visual-tests
        run: |
          # Create test results directory
          mkdir -p test-results/screenshots
          mkdir -p test-results/reports
          
          # Set viewport configuration
          case "${{ matrix.viewport }}" in
            "mobile")
              VIEWPORT_WIDTH=375
              VIEWPORT_HEIGHT=667
              ;;
            "tablet")
              VIEWPORT_WIDTH=768
              VIEWPORT_HEIGHT=1024
              ;;
            "desktop")
              VIEWPORT_WIDTH=1920
              VIEWPORT_HEIGHT=1080
              ;;
            *)
              VIEWPORT_WIDTH=1920
              VIEWPORT_HEIGHT=1080
              ;;
          esac
          
          echo "VIEWPORT_WIDTH=$VIEWPORT_WIDTH" >> $GITHUB_ENV
          echo "VIEWPORT_HEIGHT=$VIEWPORT_HEIGHT" >> $GITHUB_ENV
          
          # Pass changed files to the test script
          echo "CHANGED_FILES=${{ steps.changed-files.outputs.changed_files }}" >> $GITHUB_ENV
          
          # Create standalone visual tests script (CommonJS for compatibility)
          cat > visual-tests-workflow.cjs << 'EOF'
          const puppeteer = require('puppeteer');
          const fs = require('fs').promises;
          const path = require('path');

          const BASE_URL = 'http://localhost:4321';
          const VIEWPORT_WIDTH = parseInt(process.env.VIEWPORT_WIDTH);
          const VIEWPORT_HEIGHT = parseInt(process.env.VIEWPORT_HEIGHT);
          const BROWSER_TYPE = process.env.BROWSER_TYPE;

          // Discover pages to test based on changed files
          function discoverPagesToTest() {
            const changedFiles = process.env.CHANGED_FILES || '';
            const pages = [];
            
            console.log('Changed files from PR:', changedFiles);
            
            if (!changedFiles.trim()) {
              // If no changed files or not a PR, test common pages
              console.log('No changed page files detected, testing common pages...');
              return [
                { name: 'home', path: '/', title: 'Home Page' },
                { name: 'about', path: '/about', title: 'About Page' },
                { name: 'gallery', path: '/gallery', title: 'Gallery Page' }
              ];
            }
            
            // Always include home page as it might be affected by component changes
            pages.push({ name: 'home', path: '/', title: 'Home Page' });
            
            // Process changed files
            const changedFilesList = changedFiles.split('\n').filter(f => f.trim());
            
            changedFilesList.forEach(filePath => {
              if (filePath.startsWith('src/pages/') && (filePath.endsWith('.astro') || filePath.endsWith('.md') || filePath.endsWith('.mdx'))) {
                const fileName = filePath.replace('src/pages/', '').replace(/\.(astro|md|mdx)$/, '');
                
                // Skip index file (already handled as home)
                if (fileName === 'index') return;
                
                // Convert file path to URL path
                let urlPath = '/' + fileName;
                let pageName = fileName;
                let pageTitle = fileName.charAt(0).toUpperCase() + fileName.slice(1) + ' Page';
                
                // Handle nested paths
                if (fileName.includes('/')) {
                  const parts = fileName.split('/');
                  pageName = parts.join('-');
                  pageTitle = parts.map(p => p.charAt(0).toUpperCase() + p.slice(1)).join(' ') + ' Page';
                }
                
                // Avoid duplicates
                if (!pages.find(p => p.path === urlPath)) {
                  pages.push({
                    name: pageName,
                    path: urlPath,
                    title: pageTitle,
                    sourceFile: filePath
                  });
                }
              }
            });
            
            // Also check if any components were changed that might affect multiple pages
            const componentChanges = changedFilesList.filter(f => f.startsWith('src/components/'));
            if (componentChanges.length > 0) {
              console.log('Component changes detected, adding key pages for testing...');
              
              // Add key pages that likely use components
              const keyPages = [
                { name: 'about', path: '/about', title: 'About Page' },
                { name: 'gallery', path: '/gallery', title: 'Gallery Page' },
                { name: 'contact', path: '/contact', title: 'Contact Page' }
              ];
              
              keyPages.forEach(keyPage => {
                if (!pages.find(p => p.path === keyPage.path)) {
                  pages.push({ ...keyPage, reason: 'Component changes detected' });
                }
              });
            }
            
            console.log('Pages to test:', pages.map(p => `${p.title} (${p.path})`).join(', '));
            return pages;
          }
          
          const TEST_PAGES = discoverPagesToTest();

          async function runVisualTests() {
            const browser = await puppeteer.launch({
              headless: 'new',
              args: [
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage',
                '--disable-gpu'
              ]
            });

            const results = {
              browser: BROWSER_TYPE,
              viewport: `${VIEWPORT_WIDTH}x${VIEWPORT_HEIGHT}`,
              timestamp: new Date().toISOString(),
              tests: [],
              summary: {
                total: 0,
                passed: 0,
                failed: 0,
                warnings: 0
              }
            };

            try {
              for (const page of TEST_PAGES) {
                console.log(`Testing ${page.title} (${page.path})...`);
                
                const testResult = await testPage(browser, page);
                results.tests.push(testResult);
                results.summary.total++;
                
                if (testResult.status === 'passed') {
                  results.summary.passed++;
                } else if (testResult.status === 'failed') {
                  results.summary.failed++;
                } else {
                  results.summary.warnings++;
                }
              }

              // Save results
              await fs.writeFile(
                'test-results/reports/visual-test-results.json',
                JSON.stringify(results, null, 2)
              );

              // Generate HTML report
              await generateHtmlReport(results);

              console.log('\n=== Visual Test Summary ===');
              console.log(`Browser: ${results.browser}`);
              console.log(`Viewport: ${results.viewport}`);
              console.log(`Total Tests: ${results.summary.total}`);
              console.log(`Passed: ${results.summary.passed}`);
              console.log(`Failed: ${results.summary.failed}`);
              console.log(`Warnings: ${results.summary.warnings}`);

              // Exit with error if any tests failed
              if (results.summary.failed > 0) {
                process.exit(1);
              }

            } finally {
              await browser.close();
            }
          }

          async function testPage(browser, pageConfig) {
            const page = await browser.newPage();
            const testResult = {
              name: pageConfig.name,
              title: pageConfig.title,
              path: pageConfig.path,
              url: BASE_URL + pageConfig.path,
              status: 'passed',
              checks: [],
              screenshots: [],
              metrics: {},
              errors: []
            };

            try {
              // Set viewport
              await page.setViewport({
                width: VIEWPORT_WIDTH,
                height: VIEWPORT_HEIGHT
              });

              // Navigate to page
              const response = await page.goto(testResult.url, {
                waitUntil: 'networkidle2',
                timeout: 30000
              });

              // Check if page loaded successfully
              if (!response.ok()) {
                testResult.errors.push(`HTTP ${response.status()}: ${response.statusText()}`);
                testResult.status = 'failed';
              }

              // Take full page screenshot
              const screenshotPath = `test-results/screenshots/${pageConfig.name}-${VIEWPORT_WIDTH}x${VIEWPORT_HEIGHT}.png`;
              await page.screenshot({
                path: screenshotPath,
                fullPage: true
              });
              testResult.screenshots.push(screenshotPath);

              // Performance metrics
              const metrics = await page.metrics();
              testResult.metrics = {
                JSHeapUsedSize: Math.round(metrics.JSHeapUsedSize / 1024 / 1024 * 100) / 100,
                JSHeapTotalSize: Math.round(metrics.JSHeapTotalSize / 1024 / 1024 * 100) / 100,
                LayoutCount: metrics.LayoutCount,
                RecalcStyleCount: metrics.RecalcStyleCount
              };

              // Visual checks
              const checks = await performVisualChecks(page, pageConfig);
              testResult.checks = checks;

              // Check for JavaScript errors
              const jsErrors = await page.evaluate(() => {
                return window.jsErrors || [];
              });
              
              if (jsErrors.length > 0) {
                testResult.errors.push(...jsErrors);
                testResult.status = 'failed';
              }

              // Determine overall status
              const failedChecks = checks.filter(check => check.status === 'failed');
              const warningChecks = checks.filter(check => check.status === 'warning');
              
              if (failedChecks.length > 0 || testResult.errors.length > 0) {
                testResult.status = 'failed';
              } else if (warningChecks.length > 0) {
                testResult.status = 'warning';
              }

            } catch (error) {
              testResult.errors.push(error.message);
              testResult.status = 'failed';
            } finally {
              await page.close();
            }

            return testResult;
          }

          async function performVisualChecks(page, pageConfig) {
            const checks = [];

            try {
              // Check page title
              const title = await page.title();
              checks.push({
                name: 'Page Title',
                status: title && title.trim() !== '' ? 'passed' : 'failed',
                message: title ? `Title: "${title}"` : 'Page title is empty',
                expected: 'Non-empty page title',
                actual: title || 'Empty'
              });

              // Check for responsive meta tag
              const hasViewportMeta = await page.$('meta[name="viewport"]');
              checks.push({
                name: 'Viewport Meta Tag',
                status: hasViewportMeta ? 'passed' : 'warning',
                message: hasViewportMeta ? 'Viewport meta tag found' : 'Viewport meta tag missing',
                expected: 'Viewport meta tag present',
                actual: hasViewportMeta ? 'Present' : 'Missing'
              });

              // Check for main navigation
              const hasNavigation = await page.$('nav, [role="navigation"]');
              checks.push({
                name: 'Navigation Element',
                status: hasNavigation ? 'passed' : 'warning',
                message: hasNavigation ? 'Navigation element found' : 'Navigation element not found',
                expected: 'Navigation element present',
                actual: hasNavigation ? 'Present' : 'Missing'
              });

              // Check for images without alt text
              const imagesWithoutAlt = await page.$$eval('img:not([alt])', imgs => imgs.length);
              checks.push({
                name: 'Image Alt Text',
                status: imagesWithoutAlt === 0 ? 'passed' : 'warning',
                message: imagesWithoutAlt === 0 ? 'All images have alt text' : `${imagesWithoutAlt} images missing alt text`,
                expected: 'All images have alt text',
                actual: `${imagesWithoutAlt} images without alt text`
              });

              // Check for console errors
              const consoleErrors = [];
              page.on('console', msg => {
                if (msg.type() === 'error') {
                  consoleErrors.push(msg.text());
                }
              });

              // Wait a bit to catch any console errors
              await page.waitForTimeout(2000);

              checks.push({
                name: 'Console Errors',
                status: consoleErrors.length === 0 ? 'passed' : 'failed',
                message: consoleErrors.length === 0 ? 'No console errors' : `${consoleErrors.length} console errors found`,
                expected: 'No console errors',
                actual: consoleErrors.length > 0 ? consoleErrors.join('; ') : 'None'
              });

              // Page-specific checks
              if (pageConfig.name === 'gallery') {
                const galleryImages = await page.$$('.gallery img, [class*="gallery"] img');
                checks.push({
                  name: 'Gallery Images',
                  status: galleryImages.length > 0 ? 'passed' : 'failed',
                  message: `Found ${galleryImages.length} gallery images`,
                  expected: 'Gallery images present',
                  actual: `${galleryImages.length} images`
                });
              }

              // Check for layout shift (basic)
              const layoutShiftScore = await page.evaluate(() => {
                return new Promise((resolve) => {
                  let cumulativeLayoutShift = 0;
                  new PerformanceObserver((list) => {
                    for (const entry of list.getEntries()) {
                      if (!entry.hadRecentInput) {
                        cumulativeLayoutShift += entry.value;
                      }
                    }
                    resolve(cumulativeLayoutShift);
                  }).observe({ type: 'layout-shift', buffered: true });
                  
                  setTimeout(() => resolve(cumulativeLayoutShift), 3000);
                });
              });

              checks.push({
                name: 'Layout Stability',
                status: layoutShiftScore < 0.1 ? 'passed' : layoutShiftScore < 0.25 ? 'warning' : 'failed',
                message: `Cumulative Layout Shift: ${layoutShiftScore.toFixed(4)}`,
                expected: 'CLS < 0.1 (good)',
                actual: layoutShiftScore.toFixed(4)
              });

            } catch (error) {
              checks.push({
                name: 'Visual Checks Error',
                status: 'failed',
                message: `Error performing visual checks: ${error.message}`,
                expected: 'Successful visual checks',
                actual: 'Error occurred'
              });
            }

            return checks;
          }

          async function generateHtmlReport(results) {
            const html = `
            <!DOCTYPE html>
            <html lang="en">
            <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>Visual Test Report</title>
              <style>
                body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
                .container { max-width: 1200px; margin: 0 auto; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
                .header { background: #2563eb; color: white; padding: 20px; border-radius: 8px 8px 0 0; }
                .summary { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; padding: 20px; }
                .summary-card { background: #f8fafc; padding: 15px; border-radius: 6px; text-align: center; }
                .summary-card h3 { margin: 0 0 10px 0; color: #374151; }
                .summary-card .number { font-size: 2em; font-weight: bold; }
                .passed { color: #059669; }
                .failed { color: #dc2626; }
                .warning { color: #d97706; }
                .test-results { padding: 0 20px 20px; }
                .test-item { margin-bottom: 20px; border: 1px solid #e5e7eb; border-radius: 6px; overflow: hidden; }
                .test-header { background: #f9fafb; padding: 15px; border-bottom: 1px solid #e5e7eb; }
                .test-content { padding: 15px; }
                .checks { margin-top: 15px; }
                .check-item { display: flex; align-items: center; padding: 8px; margin: 5px 0; border-radius: 4px; }
                .check-item.passed { background: #f0fdf4; }
                .check-item.failed { background: #fef2f2; }
                .check-item.warning { background: #fffbeb; }
                .status-badge { padding: 4px 8px; border-radius: 4px; font-size: 0.8em; font-weight: bold; margin-right: 10px; }
                .screenshot { max-width: 300px; border-radius: 4px; margin: 10px 0; }
                .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin: 15px 0; }
                .metric { background: #f8fafc; padding: 10px; border-radius: 4px; text-align: center; }
              </style>
            </head>
            <body>
              <div class="container">
                <div class="header">
                  <h1>Visual Test Report</h1>
                  <p>Browser: ${results.browser} | Viewport: ${results.viewport} | ${results.timestamp}</p>
                </div>
                
                <div class="summary">
                  <div class="summary-card">
                    <h3>Total Tests</h3>
                    <div class="number">${results.summary.total}</div>
                  </div>
                  <div class="summary-card">
                    <h3>Passed</h3>
                    <div class="number passed">${results.summary.passed}</div>
                  </div>
                  <div class="summary-card">
                    <h3>Failed</h3>
                    <div class="number failed">${results.summary.failed}</div>
                  </div>
                  <div class="summary-card">
                    <h3>Warnings</h3>
                    <div class="number warning">${results.summary.warnings}</div>
                  </div>
                </div>
                
                <div class="test-results">
                  <h2>Test Results</h2>
                  ${results.tests.map(test => `
                    <div class="test-item">
                      <div class="test-header">
                        <h3>${test.title} <span class="status-badge ${test.status}">${test.status.toUpperCase()}</span></h3>
                        <p><strong>URL:</strong> ${test.url}</p>
                      </div>
                      <div class="test-content">
                        ${test.errors.length > 0 ? `
                          <div style="background: #fef2f2; padding: 10px; border-radius: 4px; margin-bottom: 15px;">
                            <strong>Errors:</strong>
                            <ul>${test.errors.map(error => `<li>${error}</li>`).join('')}</ul>
                          </div>
                        ` : ''}
                        
                        <div class="metrics">
                          <div class="metric">
                            <strong>JS Heap Used</strong><br>
                            ${test.metrics.JSHeapUsedSize || 0} MB
                          </div>
                          <div class="metric">
                            <strong>Layout Count</strong><br>
                            ${test.metrics.LayoutCount || 0}
                          </div>
                          <div class="metric">
                            <strong>Style Recalc</strong><br>
                            ${test.metrics.RecalcStyleCount || 0}
                          </div>
                        </div>
                        
                        <div class="checks">
                          <h4>Visual Checks</h4>
                          ${test.checks.map(check => `
                            <div class="check-item ${check.status}">
                              <span class="status-badge ${check.status}">${check.status.toUpperCase()}</span>
                              <div>
                                <strong>${check.name}:</strong> ${check.message}
                                ${check.expected && check.actual ? `<br><small>Expected: ${check.expected} | Actual: ${check.actual}</small>` : ''}
                              </div>
                            </div>
                          `).join('')}
                        </div>
                        
                        ${test.screenshots.length > 0 ? `
                          <div>
                            <h4>Screenshots</h4>
                            ${test.screenshots.map(screenshot => `
                              <img src="../${screenshot}" alt="Screenshot of ${test.title}" class="screenshot">
                            `).join('')}
                          </div>
                        ` : ''}
                      </div>
                    </div>
                  `).join('')}
                </div>
              </div>
            </body>
            </html>
            `;

            await fs.writeFile('test-results/reports/visual-test-report.html', html);
          }

          // Run the tests
          runVisualTests().catch(error => {
            console.error('Visual tests failed:', error);
            process.exit(1);
          });
          EOF
          
          # Run the visual tests
          BROWSER_TYPE=${{ matrix.browser }} node visual-tests-workflow.cjs

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: visual-test-results-${{ matrix.browser }}-${{ matrix.viewport }}
          path: |
            test-results/
          retention-days: 30

      - name: Comment on PR with visual test results
        if: github.event_name == 'pull_request' && always()
        run: |
          if [ -f "test-results/reports/visual-test-results.json" ]; then
            # Generate PR comment from test results
            cat > generate_comment.cjs << 'EOF'
            const fs = require('fs');
            const results = JSON.parse(fs.readFileSync('test-results/reports/visual-test-results.json', 'utf8'));
            
            const statusEmoji = {
              passed: 'âœ…',
              failed: 'âŒ',
              warning: 'âš ï¸'
            };
            
            let comment = `## ðŸ“¸ Visual Test Results - ${{ matrix.browser }} (${{ matrix.viewport }})\n\n`;
            comment += `**Summary:** ${results.summary.passed}/${results.summary.total} tests passed\n\n`;
            
            if (results.summary.failed > 0) {
              comment += `### âŒ Failed Tests (${results.summary.failed})\n`;
              results.tests.filter(t => t.status === 'failed').forEach(test => {
                comment += `- **${test.title}**: ${test.errors.join(', ')}\n`;
              });
              comment += '\n';
            }
            
            if (results.summary.warnings > 0) {
              comment += `### âš ï¸ Warnings (${results.summary.warnings})\n`;
              results.tests.filter(t => t.status === 'warning').forEach(test => {
                const warnings = test.checks.filter(c => c.status === 'warning');
                comment += `- **${test.title}**: ${warnings.map(w => w.name).join(', ')}\n`;
              });
              comment += '\n';
            }
            
            comment += `### ðŸ“Š Test Details\n`;
            results.tests.forEach(test => {
              comment += `- ${statusEmoji[test.status]} **${test.title}** (${test.path})\n`;
              if (test.checks.length > 0) {
                const checkSummary = test.checks.reduce((acc, check) => {
                  acc[check.status] = (acc[check.status] || 0) + 1;
                  return acc;
                }, {});
                comment += `  - Checks: ${Object.entries(checkSummary).map(([status, count]) => `${count} ${status}`).join(', ')}\n`;
              }
            });
            
            comment += `\n---\n*Visual tests completed at ${results.timestamp}*`;
            
            console.log(comment);
            EOF
            
            COMMENT=$(node generate_comment.cjs)
            gh pr comment ${{ github.event.pull_request.number }} --body "$COMMENT"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create issues for critical visual failures
        if: failure() && github.event_name == 'pull_request'
        run: |
          if [ -f "test-results/reports/visual-test-results.json" ]; then
            cat > create_visual_issues.cjs << 'EOF'
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            const results = JSON.parse(fs.readFileSync('test-results/reports/visual-test-results.json', 'utf8'));
            const failedTests = results.tests.filter(test => test.status === 'failed');
            
            failedTests.forEach(test => {
              const title = `ðŸ” Visual Test Failure: ${test.title} (${results.browser}/${results.viewport})`;
              const body = `## Visual Test Failure Report
            
            **Page:** ${test.title}
            **URL:** ${test.url}
            **Browser:** ${results.browser}
            **Viewport:** ${results.viewport}
            **PR:** #${{ github.event.pull_request.number }}
            
            ### Errors
            ${test.errors.map(error => `- ${error}`).join('\n')}
            
            ### Failed Checks
            ${test.checks.filter(c => c.status === 'failed').map(check => 
              `- **${check.name}**: ${check.message}`
            ).join('\n')}
            
            ### Performance Metrics
            - JS Heap Used: ${test.metrics.JSHeapUsedSize || 0} MB
            - Layout Count: ${test.metrics.LayoutCount || 0}
            - Style Recalculations: ${test.metrics.RecalcStyleCount || 0}
            
            ---
            *This issue was automatically created from visual test failures.*`;
            
              try {
                execSync(`gh issue create --title "${title}" --body "${body}" --label "visual-testing,automated-review,severity:high"`, {
                  stdio: 'inherit'
                });
              } catch (error) {
                console.error(`Failed to create issue for ${test.title}:`, error.message);
              }
            });
            EOF
            
            node create_visual_issues.cjs
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Stop preview server
        if: always()
        run: |
          if [ ! -z "$PREVIEW_PID" ]; then
            kill $PREVIEW_PID || true
          fi
          # Also kill any remaining processes on port 4321
          pkill -f "astro preview" || true

  lighthouse-audit:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch'
    needs: visual-tests
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: |
          npm ci
          npm install -g @lhci/cli@0.12.x

      - name: Build and start server
        run: |
          npm run build
          npm run preview &
          timeout 60 bash -c 'until curl -s http://localhost:4321 > /dev/null; do sleep 2; done'

      - name: Run Lighthouse CI
        run: |
          lhci autorun --config=.lighthouserc.json || lhci autorun --collect.url=http://localhost:4321 --collect.url=http://localhost:4321/about --collect.url=http://localhost:4321/gallery --collect.url=http://localhost:4321/contact --collect.url=http://localhost:4321/faq --upload.target=temporary-public-storage

      - name: Comment Lighthouse results on PR
        if: github.event_name == 'pull_request'
        run: |
          # This would typically parse Lighthouse results and comment on PR
          echo "Lighthouse audit completed - results would be posted to PR"